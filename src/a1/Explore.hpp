#ifndef EXPLORE_HPP
#define EXPLORE_HPP

#include <vector>
#include <algorithm>

#include "a1/SlamConstants.hpp"

#include <math/point.hpp>
#include <mapping/occupancy_grid.hpp>
#include <mapping/occupancy_grid_utils.hpp>
#include <lcmtypes/maebot_processed_laser_scan_t.hpp>
#include <lcmtypes/maebot_particle_map_t.hpp>

namespace eecs467 {

// for use with breadth first search and configuration space
enum Direction : char { NONE, LEFT, RIGHT, DOWN, UP };

enum State : char { EMPTY = 0, WALL = 1 << 4, UNKNOWN = 2 << 4 };

#define state(x) (x & 0xF0)
#define dir(x) (x & 0x0F)

/**
 * @brief this class handles choosing points to go explore
 */
class Explore {
private:
	std::vector<Point<int>> _wayPoints;
	Point<int> _dest;

	static bool detectObstacle(const OccupancyGrid& grid, 
		const Point<int>& start, 
		const Point<int>& end, double steps);

public:
	Explore();

	bool getNextWayPoint(const OccupancyGrid& grid, 
		const Point<int>& currPos, 
		Point<double>& nextWayPoint);

	bool getCurrentDestination(Point<int>& dest) const;

	void clearPath();

	void toLCM(maebot_particle_map_t& map, const OccupancyGrid& grid);

	/**
	 * @brief generates a configuration space
	 * @param grid reference to occupancy grid
	 * @param radius radius of the robot
	 * @return configuration space
	 */
	static OccupancyGrid getConfigurationSpace(const OccupancyGrid&, float radius);

public:
	/**
	 * @brief takes in a path generated by breadthFirstSearch and picks
	 * important waypoints from it (aka corners and whatnot)
	 * @param grid reference to our configuration space
	 * @param points path where the first element is the destination and the last element is the start
	 * @return specific points from the path where the first element is the destination
	 * and the last element is the start
	 */
	static std::vector<Point<int>> pickWayPoints(const OccupancyGrid& grid, 
		const std::vector<Point<int>>& points);

	/**
	 * @brief generates a vector of points consisting of 
	 * adjacent cells that represent a path from our position 
	 * to the nearest unknown location
	 * @param grid const ref to a configuration space
	 * @return path where the first element is the destination and the last element is the start
	 */
	static std::vector<Point<int>> breadthFirstSearch(OccupancyGrid& grid, 
		const Point<int>& currPos);

};

}

#endif /* EXPLORE_HPP */
